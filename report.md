## انجام آزمایش
ابتدا برای آنکه بتوانیم در حین انجام بازآرایی از درست کار کردن کد مطمئن شویم، یک تابع تست به پروژه اضافه می‌کنیم. این تابع را در کلاس‌های Memory, CodeGenerator پیاده‌سازی می‌کنیم، و در ابتدا فقط در آخر کلاس Parser به‌جای چاپ خروجی، تست‌کردن را انجام می‌دهیم. جزئیات عمل انجام‌شده را می‌توانید در کامیت `test: add test feature for CodeGenerator` مشاهده کنید.

### اعمال الگوی Facade
`TODO`

### استفاده از Polymorphism به‌جای شرط
یکی از موارد اعمال این عمل بازآرایی، برای کلاس Action بود. در شکل زیر کدی را می‌بینید که براساس نوع Action یک عمل را انجام می‌دهد. 
![Alt text](1.1.png)
همانطور که در شکل زیر مشاهده می‌کنید، متغیر number در انواع Shift و Reduce‌ تعبیری جدا دارد، و در Accept‌هم اصلا بلا استفاده است. همچنین تابع toString هم از شرط استفاده کرد.
![Alt text](1.2.png)
نتیجتا، این کلاس را به واسط زیر تبدیل کرده و انواع آن را جداگانه پیاده‌سازی می‌کنیم.
![Alt text](1.3.png)

### Separate Query from Modifier
یکی از مواردی از این مسئله که در کد مشاهده کردیم، در کلاس Memory است که در شکل زیر نمایان شده است. همانطور که مشاهده می‌کنید، متغیر درون کلاسی lastTempIndex در این تابع به‌ظاهر از نوع Query تغییر می‌کند. برای انجام بازآرایی، این عمل تغییر را در یک تابع دیگر و از نوع Modifier انجام می‌دهیم.
![Alt text](2.1.png)

### سایر بازآرایی‌ها

#### Self Encapsulated Field
در کلاس Address سه متغیر وجود دارد که هر سه از نوع public هستند. برای اعمال بازیابی، این متغیرها را از نوع private می‌کنیم و یک getter برایشان قرار می‌دهیم.
![Alt text](3.1.png)

#### استفاده از Polymorphism به‌جای شرط
کلاس Address در خود یک متغیر به نام Type نگه می‌دارد که نوع آن را مشخص می‌کند. در شکل زیر می‌بینید رفتار این کلاس براساس Type مشخص می‌شود.
![Alt text](4.1.png)

برای اعمال بازآرایی، به‌ازای هرنوع از Type یک subclass‌ تعریف کرده و رفتار را در آن تنظیم می‌کنیم.

#### Separate Query from Modifier
در همان فضای اعمال بازآرایی پیشین، تابع getDateAddress نیز همان مشکل را داشت، که آن را بازآرایی کردیم. می‌توانید تابع را در زیر مشاهده کنید.
![Alt text](5.1.png)
